.\" Manpage for stirmake.
.\" Contact juha-matti.tilli@iki.fi to correct errors or typos.
.TH STIRMAKE 1 "20 Aug 2019" "stirmake 0.1" "stirmake man page"
.SH NAME
stirmake \- scalable true implementation of recursive make
.SH SYNOPSIS
stirmake [-vdcb] [-j jobcnt] -f Stirfile | -t | -p | -a [target...]

smka [-vdcb] [-j jobcnt] [target...]

smkp [-vdcb] [-j jobcnt] [target...]

smkt [-vdcb] [-j jobcnt] [target...]
.SH DESCRIPTION
.I stirmake
is a replacement for make that aims for precise builds and ease of
build system maintenance. It supports recursive scoping and is
programmable in a custom strongly typed language Amyplan created
for \fIstirmake\fR.

.I stirmake
aims to have high performance which is achieved by a C-based implementation
contrary to make of its competitors (SCons, Rake) that are implemented in
slow interpreted languages (Python, Ruby, respectively).

.I stirmake
does not even attempt to have the implementation and the input language to be
the same, contrary to the already mentioned SCons and Rake and most importantly
contrary to Shake that requires one to learn a purely functional language
Haskell.

.I stirmake
aims to be compatible with existing solutions (make) when compatibility is
critical (jobserver, gcc -M format include files, parallelism with -j argument),
similar to existing solutions when the existing solutions got things mostly
right (the rule specification syntax, but now this time rule can have many
targets) and wildly different from existing solutions where existing solutions
are inadequate (string based variable substitution replaced with proper strong
typing, recursive nested scoping supported).

It has been a design goal that
.I stirmake
can be depoloyed one project at a time. Projects using make can include
submodules using
.I stirmake
and projects using
.I stirmake
can include submodules using GNU make with no difficulty at all.

Similarly to the version control system git, you can invoke
.I stirmake
within any directory in the project hierarchy and it detects its current
directory relative to project hierarchy top automatically.

.SH OPTIONS
.sp 1
.TP 0.5i
.B \-a
Build things relative to project hierarchy root. This is automatic if
.I stirmake
is invoked as \fIsmka\fR.
.TP 0.5i
.B \-b
Clean all binaries and exit, except if targets were specified, in which case
build the targets afterwards.
.TP 0.5i
.B \-c
Clean all objects and exit, except if targets were specified, in which case
build the targets afterwards.
.TP 0.5i
.B \-d
Print debugging information.
.TP 0.5i
.B \-f \fIStirfile\fR
Use \fIStirfile\fR as the file to read build instructions from.
.TP 0.5i
.B \-j \fIjobcnt\fR
Use \fIjobcnt\fR jobs. If \fIjobcnt\fR begins with \fIa\fR, detect CPU count
in the system automatically and use that as job count.
.TP 0.5i
.B \-p
Build things relative to project root. This is automatic if
.I stirmake
is invoked as \fIsmkp\fR.
.TP 0.5i
.B \-t
Build things relative to current directory. This is automatic if
.I stirmake
is invoked as \fIsmkt\fR.
.TP 0.5i
.B \-v
Print version information and exit.
.SH "STIRFILE FORMAT"
Each Stirfile must begin with a marker \fI@toplevel\fR or \fI@subfile\fR on
the first non-empty line, with the marker saying whether the file is to be
processed on its own or included as part of some other
.I stirmake
instance.

First of all, you want to create the target \fIall\fR which must be marked
\fI@phonyrule\fR so that you have a default target. This target should be the
first so that it's the default target.

.EX
@toplevel

@phonyrule: "all": "proga" "progb" "progc" "libd.a"
.EE

Note how all strings are quoted. In targets and dependencies, unquoted strings
are supported but it will emit a warning.

Then you specify shell commands for targets:

.EX
"proga": "proga.o" "libd.a"
	cc -o $@ $^
.EE

Note that $^ only lists the dependencies on the rule specification, not
any dependencies that might be defined later. So, for example, this:

.EX
"proga": "proga.o"
	cc -o $@ $^

@deponly: "proga": "libd.a"
.EE

doesn't link to the library \fIlibd.a\fR.

It's also possible to use an expression-based syntax:

.EX
(["proga"]): (["proga.o", "libd.a"])
@	["cc", "-o", $@, @$^]
.EE

where parentheses are required around expressions for targets and
dependencies, and the expression support for commands works by having @ before
the tabulator. The special variable $^ is prefixed by @ to indicate one wants
to join the full contents of the list $^ into the resulting list and not just
include the list as one list element.

The expression based syntax allows one to define arrays and functions:

.EX
$CCCMD<> = ["cc", "-o", $@, @$^]

$DEPS = ["proga.o", "libd.a"]

"proga": $DEPS
@	$CCCMD<>
.EE

Here <> in definition mean "define it as one-liner expression function", and <>
in variable reference means "call it with no arguments if it's a function".

Of course, functions can be defined in a full programming language:

.EX
@function $CCCMD($compiler)
  @locvar $appendlist = ["-o", @D $@, @ @D $^]
  @locvar $resultlist = []
  @locvar $i = 0
  @for($i = 0, $i < $appendlist[], $i = $i + 1)
    @append($resultlist, $appendlist[$i])
  @endfor
  @return $resultlist
@endfunction

$DEPS = ["proga.o", "libd.a"]

"proga": $DEPS
@	$CCCMD("gcc")
.EE

Sub-directories can be included in the following manner

.EX
@dirinclude "module1"
@dirinclude ["module2", "module3"]
$ADDMODS = ["module4, "module5"]
@dirinclude $ADDMODS
.EE

Sub-projects can be included, too, but it's recommended to control which
variables are visible so that you won't pollute the variable namespace of the
sub-project.

.EX
$ISVISIBLE = "foo"
$NOTVISIBLE = "bar"
@beginholeyscope
  $ISVISIBLE = @LP $ISVISIBLE
  @projdirinclude "subproject"
@endscope
.EE

Rules can have many targets:

.EX
stiryy.tab.c stiryy.tab.h: stiryy.y
	byacc -d -p stiryy -o stiryy.tab.c stiryy.y
.EE

Sub-makes can be invoked in the following manner:

.EX
@detouchrule: subproj/bin/cmd subproj/lib/libsp.a: @recdep subproj
	make -C subproj

@cleanhook:
	make -C subproj clean

@distcleanhook:
	false

@bothcleanhook:
	make -C subproj clobber
.EE

Here
.I @recdep
means depend on the latest mtime within the directory hierarchy and
.I @detouchrule
is required for the rule if some of the targets are inside the same hierarchy.
An alternative for
.I @detouchrule
is
.I @rectgtrule
or
.I @mayberule
but it is the author's opinion that
.I @detouchrule
works the best.

If you invoke sub-make within the same directory, the targets need to be
.I @maybe
like this:

.EX
@maybe: test: test.c test.mk
	make -f test.mk

@cleanhook:
	make -f test.mk clean

@distcleanhook:
	false

@bothcleanhook:
	make -f test.mk clobber
.EE

Stirmake generates cleaning rules automatically for its own targets, but
cleaning hooks are required for sub-makes. However, stirmake needs to know
what files are binaries and what are object files, so the rules for binaries
are marked
.I @distrule
like this:

.EX
@distrule: binfoo: binfoo.c
	cc -o binfoo binfoo.c
.EE

Each target can be listed only once, but additional dependencies can be
specified with
.I @deponly
like this:

.EX
all: foo bar
	echo all done

@deponly: all: baz
.EE

Some of the stuff can be conditional:

.EX
all: foo bar
	echo all done

$BUILD_BAZ = @false

@if($BUILD_BAZ)
  @deponly: all: baz
@endif
.EE


.SH "LUAJIT INTEGRATION"

.I stirmake
can be integrated with \fILuaJIT\fR by compiling it, either with
.I stirmake
having

.EX
$(WITH_LUA) = @true
.EE

in \fIopts.smk\fR or with GNU make having

.EX
WITH_LUA=yes
.EE

as the command-line argument. When \fILuaJIT\fR support is available,
it is possible to add Lua snippets like this that can contain
\fIAbce.getlexval\fR and \fIAbce.makelexcall\fR calls:

.EX
@function $FOO($x)
  @stdout("foo\n")
  @dump($x)
  @return $x
@endfunction

$VALUE = 2

%lua{
  print(Abce.getlexval("VALUE"))
  tbl=Abce.makelexcall("FOO", {"a", "b", 3, 4, 5, {6, {a=1, b=2, c=3}}})
  print(tbl[1])
  print(tbl[2])
  print(tbl[3])
  print(tbl[4])
  print(tbl[5])
  print(tbl[6][1])
  print(tbl[6][2]["a"])
  print(tbl[6][2]["b"])
  print(tbl[6][2]["c"])
%}
.EE

Rules/dependencies cannot be directly added from Lua, but indirectly
via Amyplan functions they can be added. Example of adding rules from Lua:

.EX
@phonyrule: 'all': 'dummy'

@function $LUARULE($x)
  @addrule($x)
@endfunction

%lua{
  function rulefromlua(x)
    local y = {tgts={{name="dummy"}}, attrs={phony=true}}
    Abce.makelexcall("LUARULE", y)
    return 0
  end
%}

@call @luacall("rulefromlua", 5)
.EE

Note here the alternative \fI@luacall\fR way of calling Lua.

Similarly,
.I @adddeps
can be invoked via an Amyplan function.

.SH "DYNAMICALLY ADDING RULES AND DEPS"

The sole argument of 
.I @addrule
is such that the tree can contain \fItgts\fR, \fIdeps\fR, \fIattrs\fR and
\fIshells\fR entries. The \fItgts\fR entry is an array of trees where every
tree contains the \fIname\fR attribute. The \fIdeps\fR entry is an array of
trees where every tree contains at least the \fIname\fR attribute, and possibly
\fIrec\fR and \fIorderonly\fR boolean attributes. The \fIattrs\fR can contain
the following attributes that are all boolean: \fIphony\fR, \fIrectgt\fR,
\fIdetouch\fR, \fImaybe\fR, \fIdist\fR, \fIdeponly\fR, \fIiscleanhook\fR,
\fIisdistcleanhook\fR, \fIisbothcleanhook\fR.

The \fIshells\fR is an array of shell invocations, where shell invocation can
have \fIembed\fR and \fIisfun\fR boolean attributes. Here \fIembed\fR means
it's an array of arrays of command-line arguments that should be embedded, and
not an array of command-line arguments that should be appended. If \fIisfun\fR
is \fI@true\fR, there are attributes \fIfun\fR for function and \fIarg\fR for
its sole argument. Otherwise, if \fIembed\fR is \fI@true\fR, you need to
specify the \fIcmds\fR argument, and if \fIembed\fR is \fI@false\fR, you need
to specify the \fIcmd\fR argument.

Rules can be added only in the parsing stage, not in the execution stage
(execution stage means from shell command hooks that are evaluated after
parsing). However, dependencies can be added in any stage, but only for
rules that have not been executed fully yet.

The three arguments of
.I @adddeps
are such that the first argument is an array of strings (target names),
the second argument is an array of strings (dependency names), and the third
argument is a tree that can contain \fIorderonly\fR and \fIrec\fR attributes
that are boolean.

.SH "INVOKING STIRMAKE"

Suppose you have the project hierarchy:

.IP "\(bu" 3
project/Stirfile
.IP "  \(bu" 5
project/dir/Stirfile
.IP "    \(bu" 7
project/dir/subproj/Stirfile
.IP "      \(bu" 9
project/dir/subproj/subdir/Stirfile
.IP "" 0
Then the following commands are equal:

.EX
cd project/dir/subproj/subdir; smkt ../all
cd project/dir/subproj/subdir; smkp all
cd project/dir/subproj/subdir; smka project/dir/subproj/all
.EE

because
.I smka
refers to whole project hierarchy,
.I smkp
refers to the current project, and
.I smkt
refers to the current diretory. In the example, it was assumed that subproj
was included with
.I @projdirinclude

.SH "EXIT STATUS"
.I stirmake
exits with zero exit status for success, if all Stirfiles could be read, parsed
and all targets / clean operations were successfully performed. An exit status
of one is used for error cases.
.SH "FILES"
.IP Stirfile 8
instructions to build a module
.IP .stir.db 8
build command database (automatically maintained)
.SH "ENVIRONMENT"
.I stirmake
gets and sets the following environment variables: MAKEFLAGS (for
GNU make compatibility), STIRMAKEPID (for communicating parent process
identifier to sub-processes).
.SH "COMPATIBILITY"
.I stirmake
is mostly incompatible with most make implementations because of the support
for data typing, support for full programmability and slightly different
syntax. However,
.I stirmake
can read make dependency files in the format make expects them, created by
e.g. the gcc -M argument. Also,
.I stirmake
speaks the GNU make jobserver protocol, being able to operate as a jobserver
host and guest.

It is expected that most conversions to
.I stirmake
involve a complete rewrite of the entire build system of the project.
.SH "SEE ALSO"
make(1)
.SH HISTORY
No history section of
.I stirmake
would be complete without mentioning the venerable make[1], created by Stuart
Feldman of AT&T Bell Laboratories. However, most users of make have found it
is a rather limited tool.

.I stirmake
was created inspired by the influential "Recursive Make Considered
Harmful" paper[2] and the author's unsuccessful attempts at creating a perfect
build system using GNU make. It seems the author is not the only one with
difficulty of creating good build systems[3]. Some of the data structures of
.I stirmake
are taken from a packet processing toolkit (PPTK) that has its origins in
2017-8.
.I stirmake
was created in 2019.
.SH "REFERENCES"
1. Feldman, S.I. (1979), Make -- a program for maintaining computer programs, Software: Practice and Experience, 9(4), pp. 255-265.

2. Miller, P.A. (1998), Recursive Make Considered Harmful, AUUGN Journal of AUUG Inc., 19(1), pp. 14-25, http://aegis.sourceforge.net/auug97.pdf

3. Mokhov, A., Mitchell, N., Peyton Jones, S., Marlow, S. (2016), Non-recursive make considered harmful: build systems at scale, ACM SIGPLAN Notices - Haskell '16, 51(12), pp. 170-181, https://www.microsoft.com/en-us/research/wp-content/uploads/2016/03/hadrian.pdf

.SH "DISTRIBUTION"
stirmake is available at https://github.com/Aalto5G/stirmake
.SH BUGS
The software is in beta, so bugs are plentiful. Here is a list of some:

.IP "\(bu" 3
Sometimes when including subdirectories / subfiles, the first rule is taken
from an included file. To avoid this, define the first rule before including
any rules.
.IP "\(bu" 3
If the first rule is dynamically added, it is ignored. If there are nothing
but dynamically added rules, it is incorrectly claimed the rule list is empty.
To avoid this, define the first rule manually with a dependency to a second
rule that is created dynamically.
.IP "\(bu" 3
Some error codes are translated to \fIUnknown error\fR instead of a descriptive
error message.
.IP "\(bu" 3
Targets may be deleted even if the list of commands to create such a target is
empty, when running clean.
.IP "\(bu" 3
There is no way to define multiple rule types, e.g. \fI@distrule\fR and
\fI@patrule\fR in the same rule.
.IP "\(bu" 3
There are plenty of memory leaks.
.IP "\(bu" 3
The output sync feature is a quick undocumented hack and not complete yet.
.IP "\(bu" 3
There is no support for \fI@elseif\fR and \fI@else\fR in top-level syntax,
although you can have these within functions.
.IP "\(bu" 3
Boolean expressions are not shortcutting currently.
.IP "\(bu" 3
\fI@cdepincludes\fR is undocumented in this man page.
.IP "\(bu" 3
\fI@patrule\fR is undocumented in this man page.
.IP "\(bu" 3
\fI@fileinclude\fR is undocumented in this man page.
.IP "\(bu" 3
\fI@strict\fR is undocumented in this man page.
.IP "\(bu" 3
\fI@-@-<TAB>\fR is undocumented in this man page.
.IP "\(bu" 3
The man page should contain plenty of examples, but it does not.
.IP "\(bu" 3
The \fI+=\fR top-level array plus-assignment operator is buggy.
.IP "" 0

.SH AUTHOR
Juha-Matti Tilli (juha-matti.tilli@iki.fi)
.SH "COPYRIGHT"
Copyright \(co 2017-9 Aalto University, 2018 Juha-Matti Tilli

Licensed under the MIT license, with the exception of logo that is not
available under this license and may only be used to represent substantially
unmodified versions of
.I stirmake
distributed under the MIT license.
