.\" Manpage for stirmake.
.\" Contact juha-matti.tilli@iki.fi to correct errors or typos.
.Dd August 30, 2019
.Os Linux
.Dt STIRMAKE 1 LOCAL
.Sh NAME
.Nm stirmake
.Nd scalable true implementation of recursive make
.Sh SYNOPSIS
.Nm stirmake
.Op Fl bcdv
.Op Fl j Ar jobcnt
.Op Fl f Ar Stirfile | Fl t | Fl p | Fl a
.Op Ar target ...
.Nm smka
.Op Fl bcdv
.Op Fl j Ar jobcnt
.Op Ar target ...
.Nm smkp
.Op Fl bcdv
.Op Fl j Ar jobcnt
.Op Ar target ...
.Nm smkt
.Op Fl bcdv
.Op Fl j Ar jobcnt
.Op Ar target ...
.Sh DESCRIPTION
.Nm stirmake
is a replacement for make that aims for precise builds and ease
of build system maintenance. It supports recursive scoping and is programmable
in a custom strongly typed language
.Nm Amyplan
created for 
.Nm stirmake .
.Pp
.Nm stirmake
aims to have high performance which is achieved by a C-based implementation
contrary to many of its competitors (SCons, Rake) that are implemented in
slow interpreted languages (Python, Ruby, respectively).
.Pp
.Nm stirmake
does not even attempt to have the implementation and the input language to be
the same, contrary to the already mentioned SCons and Rake and most importantly
contrary to Shake that requires one to learn a purely functional language
Haskell.
.Pp
.Nm stirmake
aims to be compatible with existing solutions (make) when compatibility is
critical (jobserver, 
.Nm gcc 
.Fl M
format include files, parallelism with
.Fl j
argument),
similar to existing solutions when the existing solutions got things mostly
right (the rule specification syntax, but now this time rule can have many
targets) and wildly different from existing solutions where existing solutions
are inadequate (string based variable substitution replaced with proper strong
typing, recursive nested scoping supported).
.Pp
It has been a design goal that
.Nm stirmake
can be deployed one project at a time. Projects using make can include
submodules using
.Nm stirmake
and projects using
.Nm stirmake
can include submodules using GNU make with no difficulty at all.
.Pp
Similarly to the version control system git, you can invoke
.Nm stirmake
within any directory in the project hierarchy and it detects its current
directory relative to project hierarchy top automatically.
.Sh OPTIONS
.Bl -tag -width ".Fl test Ao Ar string Ac"
.It Fl a
Build things relative to project root. This is automatic if
.Nm stirmake
is invoked as 
.Nm smka .
.It Fl b
Clean all binaries and exit, except if targets were specified, in which case
build the targets afterwards.
.It Fl c
Clean all binaries and exit, except if targets were specified, in which case
build the targets afterwards.
.It Fl d
Print debugging information.
.It Fl f Ao Ar Stirfile Ac
Use
.Ao Ar Stirfile Ac
as the file to read build instructions from.
.It Fl j Ao Ar jobcnt Ac
Use
.Ao Ar jobcnt Ac
jobs. If
.Ao Ar jobcnt Ac
begins with
.Sq a ,
detect CPU count in the system automatically and use that as
job count.
.It Fl p
Build things relative to project root. This is automatic if
.Nm stirmake
is invoked as 
.Nm smkp .
.It Fl t
Build things relative to current directory. This is automatic if
.Nm stirmake
is invoked as 
.Nm smkt .
.It Fl v
Print version information and exit.
.El
.Sh "STIRFILE FORMAT"
Each Stirfile must begin with a marker 
.Va @toplevel
or
.Va @subfile
on
the first non-empty line, with the marker saying whether the file is to be
processed on its own or included as part of some other
.Nm stirmake
instance.
.Pp
First of all, you want to create the target
.Va all
which must be marked
.Va @phonyrule
so that you have a default target. This target should be the
first so that it's the default target.
.Pp
.Bd -literal
@toplevel

@phonyrule: "all": "proga" "progb" "progc" "libd.a"
.Ed
.Pp
Note how all strings are quoted. In targets and dependencies, unquoted strings
are supported but it will emit a warning.
.Pp
Then you specify shell commands for targets:
.Pp
.Bd -literal
"proga": "proga.o" "libd.a"
	cc -o $@ $^
.Ed
.Pp
.\" FIXME is it changed now? I mean, the $^ listing only rule spec deps.
Note that
.Va $^
only lists the dependencies on the rule specification, not
any dependencies that might be defined later. So, for example, this:
.Pp
.Bd -literal
"proga": "proga.o"
	cc -o $@ $^

@deponly: "proga": "libd.a"
.Ed
.Pp
doesn't link to the library 
.Nm libd.a .
.Pp
It's also possible to use an expression-based syntax:
.Pp
.Bd -literal
(["proga"]): (["proga.o", "libd.a"])
@	["cc", "-o", $@, @$^]
.Ed
.Pp
where parentheses are required around expressions for targets and
dependencies, and the expression support for commands works by having
.Va @
before the tabulator. The special variable
.Va $^
is prefixed by
.Va @
to indicate one wants
to join the full contents of the list
.Va $^
into the resulting list and not just
include the list as one list element.
.Pp
The expression based syntax allows one to define arrays and functions:
.Pp
.Bd -literal
$CCCMD<> = ["cc", "-o", $@, @$^]

$DEPS = ["proga.o", "libd.a"]

"proga": $DEPS
@	$CCCMD<>
.Ed
.Pp
Here
.Va <>
in definition mean "define it as one-liner expression function", and
.Va <>
in variable reference means "call it with no arguments if it's a function".
.Pp
Of course, functions can be defined in a full programming language:
.Pp
.Bd -literal
@function $CCCMD($compiler)
  @locvar $appendlist = ["-o", @D $@, @ @D $^]
  @locvar $resultlist = []
  @locvar $i = 0
  @for($i = 0, $i < $appendlist[], $i = $i + 1)
    @append($resultlist, $appendlist[$i])
  @endfor
  @return $resultlist
@endfunction

$DEPS = ["proga.o", "libd.a"]

"proga": $DEPS
@	$CCCMD("gcc")
.Ed
.Pp
Sub-directories can be included in the following manner
.Pp
.Bd -literal
@dirinclude "module1"
@dirinclude ["module2", "module3"]
$ADDMODS = ["module4, "module5"]
@dirinclude $ADDMODS
.Ed
.Pp
Sub-projects can be included, too, but it's recommended to control which
variables are visible so that you won't pollute the variable namespace of the
sub-project.
.Pp
.Bd -literal
$ISVISIBLE = "foo"
$NOTVISIBLE = "bar"
@beginholeyscope
  $ISVISIBLE = @LP $ISVISIBLE
  @projdirinclude "subproject"
@endscope
.Ed
.Pp
Rules can have many targets:
.Pp
.Bd -literal
stiryy.tab.c stiryy.tab.h: stiryy.y
	byacc -d -p stiryy -o stiryy.tab.c stiryy.y
.Ed
.Pp
Sub-makes can be invoked in the following manner:
.Pp
.Bd -literal
@detouchrule: subproj/bin/cmd subproj/lib/libsp.a: @recdep subproj
	make -C subproj

@cleanhook:
	make -C subproj clean

@distcleanhook:
	false

@bothcleanhook:
	make -C subproj clobber
.Ed
.Pp
Here
.Va @recdep
means depend on the latest mtime within the directory hierarchy and
.Va @detouchrule
is required for the rule if some of the targets are inside the same hierarchy.
An alternative for
.Va @detouchrule
is
.Va @rectgtrule
or
.Va @mayberule
but it is the author's opinion that
.Va @detouchrule
works the best.
.Pp
If you invoke sub-make within the same directory, the targets need to be
.Va @maybe
like this:
.Pp
.Bd -literal
@maybe: test: test.c test.mk
	make -f test.mk

@cleanhook:
	make -f test.mk clean

@distcleanhook:
	false

@bothcleanhook:
	make -f test.mk clobber
.Ed
.Pp
Stirmake generates cleaning rules automatically for its own targets, but
cleaning hooks are required for sub-makes. However, 
.Nm stirmake
needs to
know what files are binaries and what are object files, so the rules for
binaries are marked
.Va @distrule
like this:
.Pp
.Bd -literal
@distrule: binfoo: binfoo.c
	cc -o binfoo binfoo.c
.Ed
.Pp
Each target can be listed only once, but additional dependencies can be
specified with
.Va @deponly
like this:
.Pp
.Bd -literal
all: foo bar
	echo all done

@deponly: all: baz
.Ed
.Pp
Some of the stuff can be conditional:
.Pp
.Bd -literal
all: foo bar
	echo all done

$BUILD_BAZ = @false

@if($BUILD_BAZ)
  @deponly: all: baz
@endif
.Ed
.Sh "LUAJIT INTEGRATION"
.Pp
.Nm stirmake
can be integrated with
.Nm LuaJIT
by compiling it, either with
.Nm stirmake
having
.Pp
.Bd -literal
$(WITH_LUA) = @true
.Ed
.Pp
in
.Nm opts.smk
or with GNU make having
.Pp
.Bd -literal
WITH_LUA=yes
.Ed
.Pp
as the command-line argument. When
.Nm LuaJIT
support is available,
it is possible to add Lua snippets like this that can contain
.Fn Abce.getlexval ,
.Fn Abce.getdynval ,
.Fn Abce.makelexcall
and
.Fn Abce.makedyncall
calls:
.Pp
.Bd -literal
@function $FOO($x)
  @stdout("foo\\n")
  @dump($x)
  @return $x
@endfunction

$VALUE = 2

%lua{
  print(Abce.getlexval("VALUE"))
  tbl=Abce.makelexcall("FOO", {"a", "b", 3, 4, 5, {6, {a=1, b=2, c=3}}})
  print(tbl[1])
  print(tbl[2])
  print(tbl[3])
  print(tbl[4])
  print(tbl[5])
  print(tbl[6][1])
  print(tbl[6][2]["a"])
  print(tbl[6][2]["b"])
  print(tbl[6][2]["c"])
%}
.Ed
.Pp
The difference between the
.Sq lex
and
.Sq dyn
variants is that
.Sq lex
refers to lexical scoping and
.Sq dyn
refers to dynamic scoping.
.Pp
Rules/dependencies cannot be directly added from Lua, but indirectly
via
.Nm Amyplan
functions they can be added. Example of adding rules from Lua:
.Pp
.Bd -literal
@phonyrule: 'all': 'dummy'

@function $LUARULE($x)
  @addrule($x)
@endfunction

%lua{
  function rulefromlua(x)
    local y = {tgts={{name="dummy"}}, attrs={phony=true}}
    Abce.makelexcall("LUARULE", y)
    return 0
  end
%}

@call @luacall("rulefromlua", 5)
.Ed
.Pp
Note here the alternative 
.Fn @luacall
way of calling Lua.
.Pp
Similarly,
.Fn @adddeps
can be invoked via an
.Nm Amyplan
function.
.Sh "DYNAMICALLY ADDING RULES AND DEPS"
The sole argument of 
.Fn @addrule
is such that the tree can contain 
.Va tgts ,
.Va deps ,
.Va attrs
and
.Va shells
entries. The
.Va tgts
entry is an array of trees where every
tree contains the 
.Va name
attribute. The
.Va deps
entry is an array of
trees where every tree contains at least the 
.Va name
attribute, and possibly
.Va rec
and
.Va orderonly
boolean attributes. The
.Va attrs
can contain
the following attributes that are all boolean: 
.Va phony ,
.Va rectgt ,
.Va detouch ,
.Va maybe ,
.Va dist ,
.Va deponly ,
.Va iscleanhook ,
.Va isdistcleanhook
and
.Va isbothcleanhook .
.Pp
The
.Va shells
is an array of shell invocations, where shell invocation can
have 
.Va embed
and
.Va isfun
boolean attributes. Here
.Va embed
means
it's an array of arrays of command-line arguments that should be embedded, and
not an array of command-line arguments that should be appended. If
.Va isfun
is
.Dv @true ,
there are attributes 
.Va fun
for function and
.Va arg
for its sole argument. Otherwise, if
.Va embed
is
.Dv @true ,
you need to
specify the
.Va cmds
argument, and if
.Va embed
is
.Dv @false ,
you need to specify the
.Va cmd
argument.
.Pp
Rules can be added only in the parsing stage, not in the execution stage
(execution stage means from shell command hooks that are evaluated after
parsing). However, dependencies can be added in any stage, but only for
rules that have not been executed fully yet.
.Pp
The three arguments of
.Fn @adddeps
are such that the first argument is an array of strings (target names),
the second argument is an array of strings (dependency names), and the third
argument is a tree that can contain
.Va orderonly
and
.Va rec
attributes that are boolean.
.Sh "INVOKING STIRMAKE"
Suppose you have the project hierarchy:
.Pp
.Bl -bullet -compact
.It
project/Stirfile
.It
project/dir/Stirfile
.It
project/dir/subproj/Stirfile
.It
project/dir/subproj/subdir/Stirfile
.El
.Pp
Then the following commands are equal:
.Pp
.Bd -literal
cd project/dir/subproj/subdir; smkt ../all
cd project/dir/subproj/subdir; smkp all
cd project/dir/subproj/subdir; smka dir/subproj/all
.Ed
.Pp
because
.Nm smka
refers to whole project hierarchy,
.Nm smkp
refers to the current project, and
.Nm smkt
refers to the current diretory. In the example, it was assumed that subproj
was included with
.Va @projdirinclude
.Sh "EXIT STATUS"
.Nm stirmake
exits with zero exit status for success, if all Stirfiles could be read, parsed
and all targets / clean operations were successfully performed. An exit status
of one is used for error cases.
.Sh "FILES"
.Pa Stirfile
instructions to build a module
.Pp
.Pa .stir.db
build command database (automatically maintained)
.Sh "ENVIRONMENT"
.Nm stirmake
gets and sets the following environment variables:
.Ev MAKEFLAGS
(for GNU make compatibility),
.Ev STIRMAKEPID
(for communicating parent process identifier to sub-processes).
.Sh "COMPATIBILITY"
.Nm stirmake
is mostly incompatible with most make implementations because of the support
for data typing, support for full programmability and slightly different
syntax. However,
.Nm stirmake
can read make dependency files in the format make expects them, created by
e.g. the gcc -M argument. Also,
.Nm stirmake
speaks the GNU make jobserver protocol, being able to operate as a jobserver
host and guest.
.Pp
It is expected that most conversions to
.Nm stirmake
involve a complete rewrite of the entire build system of the project.
.Sh "SEE ALSO"
make(1)
.Sh HISTORY
No history section of
.Nm stirmake
would be complete without mentioning the venerable make[1], created by Stuart
Feldman of AT&T Bell Laboratories. However, most users of make have found it
is a rather limited tool.
.Pp
.Nm stirmake
was created inspired by the influential "Recursive Make Considered
Harmful" paper[2] and the author's unsuccessful attempts at creating a perfect
build system using GNU make. It seems the author is not the only one with
difficulty of creating good build systems[3]. Some of the data structures of
.Nm stirmake
are taken from a packet processing toolkit (PPTK) that has its origins in
2017-8.
.Nm stirmake
was created in 2019.
.Sh "REFERENCES"
.Bl -enum
.It
Feldman, S.I. (1979), Make -- a program for maintaining computer programs, Software: Practice and Experience, 9(4), pp. 255-265.
.It
Miller, P.A. (1998), Recursive Make Considered Harmful, AUUGN Journal of AUUG Inc., 19(1), pp. 14-25, http://aegis.sourceforge.net/auug97.pdf
.It
Mokhov, A., Mitchell, N., Peyton Jones, S., Marlow, S. (2016), Non-recursive make considered harmful: build systems at scale, ACM SIGPLAN Notices - Haskell '16, 51(12), pp. 170-181, https://www.microsoft.com/en-us/research/wp-content/uploads/2016/03/hadrian.pdf
.El
.Sh "DISTRIBUTION"
stirmake is available at https://github.com/Aalto5G/stirmake
.Sh BUGS
The software is in beta, so bugs are plentiful. Here is a list of some:
.Bl -bullet
.It
Sometimes when including subdirectories / subfiles, the first rule is taken
from an included file. To avoid this, define the first rule before including
any rules.
.It
If the first rule is dynamically added, it is ignored. If there are nothing
but dynamically added rules, it is incorrectly claimed the rule list is empty.
To avoid this, define the first rule manually with a dependency to a second
rule that is created dynamically.
.It
Some error codes are translated to
.Dq "Unknown error"
instead of a descriptive
error message.
.It
Targets may be deleted even if the list of commands to create such a target is
empty, when running clean.
.It
There is no way to define multiple rule types, e.g. 
.Va @distrule
and
.Va @patrule
in the same rule.
.It
There are plenty of memory leaks.
.It
The output sync feature is a quick undocumented hack and not complete yet.
.It
There is no support for 
.Va @elseif
and
.Va @else
in top-level syntax,
although you can have these within functions.
.It
Boolean expressions are not shortcutting currently.
.It
.Va @cdepincludes
is undocumented in this man page.
.It
.Va @patrule
is undocumented in this man page.
.It
.Va @fileinclude
is undocumented in this man page.
.It
.Va @strict
is undocumented in this man page.
.It
.Va @-@-<TAB>
is undocumented in this man page.
.It
The man page should contain plenty of examples, but it does not.
.It
The 
.Va +=
top-level array plus-assignment operator is buggy.
.It
The shell is not actually ever invoked unless specifically requested by 
.Ic "sh -c" .
.It
The command-line syntax does not support quoted strings, breaking command-line
to arguments by spaces even if the space is inside a quoted string. To avoid
this, use the 
.Va @-<TAB>
expression based syntax that allows you to specify
every command-line argument as a strongly typed string.
.It
.Nm stirmake
can be slightly slower for null builds than GNU make if the GNU make system is
extremely well designed. However, who has seen an extremely well designed GNU
make based build system? The author of
.Nm stirmake
certainly hasn't seen
such systems except those done by the author himself.
.El
.Sh AUTHOR
Juha-Matti Tilli (juha-matti.tilli@iki.fi)
.Sh "COPYRIGHT"
Copyright \(co 2017-9 Aalto University, 2018 Juha-Matti Tilli
.Pp
Licensed under the MIT license, with the exception of logo that is not
available under this license and may only be used to represent substantially
unmodified versions of
.Nm stirmake
distributed under the MIT license.
